#! /bin/sh /usr/share/dpatch/dpatch-run
## 92_modify-execv-to-execvp-accepting-4096-cmd-args-for-b.dpatch by Michael Friedrich <michael.friedrich@univie.ac.at>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Allow 4096 cmd args for execvp

@DPATCH@


diff --git a/Changelog b/Changelog
index e2a3f70..9de507c 100644
--- a/Changelog
+++ b/Changelog
@@ -2,6 +2,23 @@
 Icinga 1.0.x Change Log
 #######################
 
+1.0.3 - 18/08/2010
+
+ENHANCEMENTS
+
+FIXES
+* core: check permissions before calling execv on a command
+* core: fix temp_path overwritten by check_result_path in base/config.c
+* core: modify execv to execvp, accepting 4096 cmd args, for both host and service checks with adapted error handling
+
+* classic ui: fix image urls ins stylesheets
+
+* install: fix api not installed using make install-unstripped
+* install: enable debuginfo in spec file
+
+* idoutils: adapt oracle-drop.sql for current schema
+
+
 1.0.2 - 30/06/2010
 
 ENHANCEMENTS
@@ -9,7 +26,7 @@ ENHANCEMENTS
 * core: check if icinga running before starting; if died remove lockfile first
 * core: add in sync retention facility (Ton Voon, Opsera Ltd)
 * core: add new is_volatile setting of 2 for services, which respects the re-notification interval for notifications (Ton Voon)
-* core: add Icinga option -S functions much like -s but will dump the entire scheduling queue is it would run, 
+* core: add Icinga option -S functions much like -s but will dump the entire scheduling queue is it would run,
         in addition to providing the summary data (Steven (Steven D. Morrey)
 * core: icinga can send log messages to syslogd using a local facility instead of the default one
 * core: enhanced diagnostic output when a regular expression fails to compile (Max Schubert)
@@ -107,7 +124,7 @@ ENHANCEMENTS
 * core: add service_check_timeout_state	configuration variable
 	This setting determines the state Icinga will report when a
 	service check times out - it does not respond within
-	service_check_timeout seconds.  
+	service_check_timeout seconds.
 	c - Critical (default)
 	u - Unknown
 	w - Warning
@@ -119,7 +136,7 @@ ENHANCEMENTS
 	escalation_condition <condition> ( [ & / | ] <condition> )*
 	where <condition> is either host hostname = [u,d,o] or
 	service hostname.service_description] = [w,u,c,o].
-	The escalation_condition accepts a list of one or more conditions 
+	The escalation_condition accepts a list of one or more conditions
 	separated by & (logical AND) or | (logical OR).
 	w = WARNING
 	u = UNKNOWN
@@ -149,7 +166,7 @@ ENHANCEMENTS
 		- dynamic binded procedure for DELETE on table by instance_id called at startup
 		  for cleaning config/status
 		- dynamic binded procedure for DELETE on tably by instance_id, field<time called
-		  during periodic cleanup in threaded housekeeper 
+		  during periodic cleanup in threaded housekeeper
 		- all other queries are prepared with their own statement handler
 			 4x DELETE
 			 52x MERGE
@@ -171,7 +188,7 @@ ENHANCEMENTS
 * idoutils: add initial debug output for idomod (to be set in idomod.cfg)
 * idoutils: add database name in connection msg to syslog
 * idoutils: change mysql db engine to innodb (no table locking, better transcations)
-* idoutils: add --with-oracle-lib=/path/to/instantclient for runtime export of 
+* idoutils: add --with-oracle-lib=/path/to/instantclient for runtime export of
 	LD_LIBRARY_PATH if instantclient not installed to path
 * idoutils: add max_logentries_age and max_acknowledgements_age to ido2db (check ido2db.cfg)
 
@@ -181,7 +198,7 @@ FIXES
 * core: fix event broker callback function self de-registering for callbacks (Sean Millichamp)
 * core: add missing sound.js provided by scriptaculous
 * core: string replaces for icinga
-* core: typo fix in mrtg.cfg (Dennis van Zuijlekom) 
+* core: typo fix in mrtg.cfg (Dennis van Zuijlekom)
 * core: add init info as required by LSB
 * core: fix perl tests
 * core: fix missing clean & distclean against tap/ directory
@@ -195,7 +212,7 @@ FIXES
 * core: fix idomod doesn't de-initialize after config error
 * core: fix make fullinstall/idoutils without enabled idoutils during configure
 * core: fix sending two identical service_status events to neb module
-* core: fix segmentation fault crash when a non-existant host or service is passed to the command pipe 
+* core: fix segmentation fault crash when a non-existant host or service is passed to the command pipe
 * core: add check for NULL for event_list_high
 
 * idoutils: modify string escaping for mysql and pgsql
@@ -320,7 +337,7 @@ FIXES
 * idoutils: add insert-or-update functions in dbqueries.c, prepared for more rdbms
 * idoutils: modify insert-or-update queries, build data array for functions
 * idoutils: fix string escaping for postgresql
-* idoutils: fix last insert id for postgresql - needs defined sequence id for table 
+* idoutils: fix last insert id for postgresql - needs defined sequence id for table
 * idoutils: modify command_line in commands table to varchar(1024)
 * idoutils: add more debug output
 * idoutils: Support 8192 chars of perfdata
@@ -371,7 +388,7 @@ FIXES
 Nagios 3.x Change Log
 #####################
 
-This is an archived Changelog, all changes on the Icinga Core will be marked and 
+This is an archived Changelog, all changes on the Icinga Core will be marked and
 referenced through issues marking on dev.icinga.org regarding their origin.
 
 Look at www.nagios.org for an actual changelog of Nagios Core.
@@ -493,7 +510,7 @@ WARNINGS
 
 3.0.5 - 11/04/2008
 ------------------
-* Security fix for Cross Site Request Forgery (CSRF) bug reported by Tim Starling. 
+* Security fix for Cross Site Request Forgery (CSRF) bug reported by Tim Starling.
 * Sample audio files for CGIs removed from distribution
 * Fix for mutliline config file continuation bug
 * Minor fix to RPM spec file
@@ -622,7 +639,7 @@ WARNINGS
 * Fix for compilation bug on systems that don't support setenv() (e.g. Solaris)
 * Support for line continuation/breaks in config files - end lines with one backslash (\) to continue on next line
 * Fixed bug with not deleting old check result files that contained results for invalid host/service
-* Fixed bug with init script option to check Nagios config 
+* Fixed bug with init script option to check Nagios config
 * Auto-filled comment/author fields for acknowledging problems through WAP interface
 * Fixed bug with processing of CONTACTGROUPNAMES, NOTES, NOTESURL, and ACTIONURL macros
 * Doc fix regarding soft state dependencies
@@ -704,7 +721,7 @@ WARNINGS
 * New macros: $HOSTGROUPMEMBERS$, $HOSTGROUPNOTES$, $HOSTGROUPNOTESURL$, $HOSTGROUPACTIONURL$, $SERVICEGROUPMEMBERS$, $SERVICEGROUPNOTES$, $SERVICEGROUPNOTESURL$, $SERVICEGROUPACTIONURL$, $CONTACTGROUPALIAS$, $CONTACTGROUPMEMBERS$, $NOTIFICATIONRECIPIENTS$, $NOTIFICATIONAUTHOR$, $NOTIFICATIONAUTHORNAME$, $NOTIFICATIONAUTHORALIAS$, $NOTIFICATIONCOMMENT$
 * Removed host/service downtime author/comment macros introduced in 3.0b2 in favor of more generic $NOTIFICATION...$ macros
 * Fix for segfault when cancelling active scheduled host downtime
-* Macro code cleanup 
+* Macro code cleanup
 * Added on-demand contact and contactgroup macro support
 * More complete (but still partial) support for macros in CGIs ($xNOTES$, $xNOTESURL$, and $xACTIONURL$ macros)
 * Fixed bug in config CGI with displaying incorrect notification interval for escalations
@@ -723,7 +740,7 @@ WARNINGS
 ------------------
 * Minor bug fix for debug logging of macros
 * Version number is now printed in CGI pages
-* HTML documentation cleanup (HTML Tidy, link checking, etc.) 
+* HTML documentation cleanup (HTML Tidy, link checking, etc.)
 * Fixed bug where notifications would not be sent out host/service contact group members
 
 
@@ -963,5 +980,5 @@ Here are all the changes since Nagios 2.x:
        and $SERVICEACKAUTHORALIAS$ macros
 
 
- 
+
 
diff --git a/base/checks.c b/base/checks.c
index 9f63052..d863a58 100644
--- a/base/checks.c
+++ b/base/checks.c
@@ -121,8 +121,166 @@ extern unsigned long max_debug_file_size;
 extern int      use_embedded_perl;
 #endif
 
+/******************************************************************/
+/********************* MISCELLANEOUS FUNCTIONS ********************/
+/******************************************************************/
+
+/* extract check result */
+static void extract_check_result(FILE *fp,dbuf *checkresult_dbuf){
+	char output_buffer[MAX_INPUT_BUFFER]="";
+	char *temp_buffer;
+
+	/* initialize buffer */
+	strcpy(output_buffer,"");
+
+	/* get all lines of plugin output - escape newlines */
+	while(fgets(output_buffer,sizeof(output_buffer)-1,fp)){
+		temp_buffer=escape_newlines(output_buffer);
+		dbuf_strcat(checkresult_dbuf,temp_buffer);
+		my_free(temp_buffer);
+	}
+}
+
+/* convert a command line to an array of arguments, suitable for exec* functions */
+static int parse_command_line(char *cmd, char *argv[MAX_CMD_ARGS]){
+	unsigned int argc=0;
+	char *parsed_cmd;
+
+	/* Skip initial white-space characters. */
+	for(parsed_cmd=cmd;isspace(*cmd);++cmd)
+		;
+
+	/* Parse command line. */
+	while(*cmd&&(argc<MAX_CMD_ARGS-1)){
+		argv[argc++]=parsed_cmd;
+
+		switch(*cmd){
+			case '\'':
+				while((*cmd)&&(*cmd!='\''))
+					*(parsed_cmd++)=*(cmd++);
+				if(*cmd)
+					++cmd;
+				break;
+			case '"':
+				while((*cmd)&&(*cmd!='"')){
+					if((*cmd=='\\')&&cmd[1]&&strchr("\"\\\n",cmd[1]))
+						++cmd;
+					*(parsed_cmd++)=*(cmd++);
+				}
+				if(*cmd)
+					++cmd;
+				break;
+			default:
+				while((*cmd)&&!isspace(*cmd)){
+					if((*cmd=='\\')&&cmd[1])
+						++cmd;
+					*(parsed_cmd++)=*(cmd++);
+				}
+		}
+
+		while(isspace(*cmd))
+			++cmd;
+
+		if(argc>=MAX_CMD_ARGS-1){
+			logit(NSLOG_RUNTIME_WARNING,TRUE,"overlimit args for command %s\n",argv[0]);
+			_exit(STATE_UNKNOWN);
+		}
+		else
+			*(parsed_cmd++)='\0';
+	}
+
+	argv[argc]=NULL;
+
+	return OK;
+}
+
+/* run a check */
+static int run_check(char *processed_command,dbuf *checkresult_dbuf){
+	char *argv[MAX_CMD_ARGS];
+	FILE *fp;
+	pid_t pid;
+	int pipefds[2];
+	int retval;
+
+	/* check for check execution method (shell or execvp) */
+	if(!has_shell_metachars(processed_command)){
+
+		if(pipe(pipefds)<0){
+			logit(NSLOG_RUNTIME_WARNING,TRUE,"error creating pipe: %s\n", strerror(errno));
+			_exit(STATE_UNKNOWN);
+		}
+		if((pid=fork())<0){
+			logit(NSLOG_RUNTIME_WARNING,TRUE,"fork error\n");
+			_exit(STATE_UNKNOWN);
+		}
+		else if(!pid){
+			/* child replaces stdout/stderr with output of the pipe */
+			if((dup2(pipefds[1],STDOUT_FILENO)<0)||(dup2(pipefds[1],STDERR_FILENO)<0)){
+				logit(NSLOG_RUNTIME_WARNING,TRUE,"dup2 error\n");
+				_exit(STATE_UNKNOWN);
+			}
+
+			/* close unused half of pipe */
+			close(pipefds[1]);
+
+			/* extract command args for execv */
+			parse_command_line(processed_command,argv);
+
+			if(!argv[0])
+				_exit(STATE_UNKNOWN);
+
+			/* check if plugin there/executable */
+			if (access(argv[0], R_OK) !=0 ) {
+				fprintf(stdout,"plugin %s does not exist or is not readable\n",argv[0]);
+				logit(NSLOG_RUNTIME_WARNING,TRUE,"plugin %s does not exists or is not readable\n",argv[0]);
+				_exit(STATE_UNKNOWN);
+			}
+
+			if (access(argv[0], X_OK) != 0  ) {
+				fprintf(stdout,"wrong execution permissions on plugin %s\n",argv[0]);
+				logit(NSLOG_RUNTIME_WARNING,TRUE,"wrong execution permissions on plugin %s\n",argv[0]);
+				_exit(STATE_UNKNOWN);
+			}
 
+			log_debug_info(DEBUGL_CHECKS,0,"running process %s via execv\n",processed_command);
+			execvp(argv[0], argv); /* instead of execvp since we don't use path */
+			_exit(STATE_UNKNOWN);
+		}
+
+		/* prepare pipe reading */
+		close(pipefds[1]);
+		fp=fdopen(pipefds[0],"r");
+		if(!fp){
+			logit(NSLOG_RUNTIME_WARNING,TRUE,"fdopen error\n");
+			_exit(STATE_UNKNOWN);
+		}
 
+		/* extract check result */
+		extract_check_result(fp,checkresult_dbuf);
+
+		/* close the process */
+		fclose(fp);
+		close(pipefds[0]);
+
+		if(waitpid(pid,&retval,0)!=pid)
+			retval=-1;
+	}
+	else{
+		log_debug_info(DEBUGL_CHECKS,0,"running process %s via popen\n",processed_command);
+		fp=popen(processed_command,"r");
+
+		if(fp==NULL)
+			_exit(STATE_UNKNOWN);
+
+		/* extract check result */
+		extract_check_result(fp,checkresult_dbuf);
+
+		/* close the process */
+		retval=pclose(fp);
+	}
+
+	return retval;
+}
 
 
 /******************************************************************/
@@ -330,14 +488,12 @@ int run_scheduled_service_check(service *svc, int check_options, double latency)
 int run_async_service_check(service *svc, int check_options, double latency, int scheduled_check, int reschedule_check, int *time_is_valid, time_t *preferred_time){
 	char *raw_command=NULL;
 	char *processed_command=NULL;
-	char output_buffer[MAX_INPUT_BUFFER]="";
 	char *temp_buffer=NULL;
 	struct timeval start_time,end_time;
 	pid_t pid=0;
 	int fork_error=FALSE;
 	int wait_result=0;
 	host *temp_host=NULL;
-	FILE *fp=NULL, *chldfp;
 	int pclose_result=0;
 	mode_t new_umask=077;
 	mode_t old_umask;
@@ -346,7 +502,6 @@ int run_async_service_check(service *svc, int check_options, double latency, int
 	dbuf checkresult_dbuf;
 	int dbuf_chunk=1024;
 	int pipefds[2], chldstatus, i;
-	char *chldargs[MAXCHLDARGS];
 	char *s , *p;
 
 #ifdef USE_EVENT_BROKER
@@ -557,7 +712,7 @@ int run_async_service_check(service *svc, int check_options, double latency, int
 		else
 			args[3]=processed_command+strlen(fname)+1;
 
-		ENTER; 
+		ENTER;
 		SAVETMPS;
 		PUSHMARK(SP);
 		XPUSHs(sv_2mortal(newSVpv(args[0],0)));
@@ -610,7 +765,7 @@ int run_async_service_check(service *svc, int check_options, double latency, int
 				fprintf(check_result_info.output_file_fp,"early_timeout=%d\n",check_result_info.early_timeout);
 				fprintf(check_result_info.output_file_fp,"exited_ok=%d\n",check_result_info.exited_ok);
 				fprintf(check_result_info.output_file_fp,"return_code=%d\n",check_result_info.return_code);
-				fprintf(check_result_info.output_file_fp,"output=%s\n",(checkresult_dbuf.buf==NULL)?"(null)":checkresult_dbuf.buf); 
+				fprintf(check_result_info.output_file_fp,"output=%s\n",(checkresult_dbuf.buf==NULL)?"(null)":checkresult_dbuf.buf);
 
 				/* close the temp file */
 				fclose(check_result_info.output_file_fp);
@@ -702,7 +857,7 @@ int run_async_service_check(service *svc, int check_options, double latency, int
 				/* execute our previously compiled script - from call_pv("Embed::Persistent::eval_file",..) */
 				/* NB. args[2] is _now_ a code ref (to the Perl subroutine corresp to the plugin) returned by eval_file() */
 
-				ENTER; 
+				ENTER;
 				SAVETMPS;
 				PUSHMARK(SP);
 
@@ -751,11 +906,11 @@ int run_async_service_check(service *svc, int check_options, double latency, int
 					fprintf(check_result_info.output_file_fp,"early_timeout=%d\n",check_result_info.early_timeout);
 					fprintf(check_result_info.output_file_fp,"exited_ok=%d\n",check_result_info.exited_ok);
 					fprintf(check_result_info.output_file_fp,"return_code=%d\n",check_result_info.return_code);
-					fprintf(check_result_info.output_file_fp,"output=%s\n",(checkresult_dbuf.buf==NULL)?"(null)":checkresult_dbuf.buf); 
+					fprintf(check_result_info.output_file_fp,"output=%s\n",(checkresult_dbuf.buf==NULL)?"(null)":checkresult_dbuf.buf);
 
 					/* close the temp file */
 					fclose(check_result_info.output_file_fp);
-					
+
 					/* move check result to queue directory */
 					move_check_result_to_queue(check_result_info.output_file);
 					}
@@ -772,111 +927,10 @@ int run_async_service_check(service *svc, int check_options, double latency, int
 #endif
 			/******** END EMBEDDED PERL INTERPRETER EXECUTION ********/
 
-     
-			/* run the plugin check command */
-
-            		if (!has_shell_metachars(processed_command)){
-                		if (pipe(pipefds) == -1){
-                    			logit(NSLOG_RUNTIME_WARNING,TRUE,"error creating pipe: %s\n",strerror(errno));
-                    			_exit(STATE_UNKNOWN);
-                		}
-
-
-                		pid = fork();
-                		if (pid == -1){
-                    			logit(NSLOG_RUNTIME_WARNING,TRUE,"fork error\n");
-                    			_exit(STATE_UNKNOWN);
-                		}
-
-	                     if (pid == 0){
-	                     close(pipefds[0]);
-	 
-	                     if (dup2(pipefds[1],STDOUT_FILENO) == -1){
-	                         logit(NSLOG_RUNTIME_WARNING,TRUE,"dup2 error\n");
-	                         _exit(EXIT_FAILURE);
-	                     }
-	 
-	                     if (dup2(pipefds[1],STDERR_FILENO) == -1){
-	                         logit(NSLOG_RUNTIME_WARNING,TRUE,"dup2 error\n");
-	                         _exit(EXIT_FAILURE);
-	                     }
-	                     close(pipefds[0]);
-	 
-	                     s = strchr(processed_command,' ');
-	                     if (s){
-	                         *s = '\0';
-	                         p = s+1;
-				 for(;isspace(*p);p++)
-					;
-	 
-	                         chldargs[0] = processed_command;
-	                         for(i=1;i<MAXCHLDARGS-2;i++){
-	                             s = strchr(p,' ');
-	                             chldargs[i] = p;
-	 
-	                             if (s){
-	                                 *s = '\0';
-	                                 p = s+1;
-					 for(;isspace(*p);p++)
-						;
-	                             }
-	 
-	                             if (!s)
-	                                 break;
-	                         }
-	 
-	                         if (i >= MAXCHLDARGS-2){
-	                             logit(NSLOG_RUNTIME_WARNING,TRUE,"overlimit args for command %s\n",chldargs[0]);
-	                             _exit(EXIT_FAILURE);
-	                         }
-	                         else
-	                             chldargs[++i] = '\0';
-	                     }
-	                     else{
-	                         chldargs[0] = processed_command;
-	                         chldargs[1] = '\0';
-	                     }
-	 
-	                     log_debug_info(DEBUGL_CHECKS,0,"running process %s via execv\n",processed_command);
-	                     execv(chldargs[0],chldargs);
-                     	    _exit(EXIT_FAILURE);
-			}
 
+			/* run the plugin check command */
+			pclose_result=run_check(processed_command,&checkresult_dbuf);
 
-	               	close(pipefds[1]);
-	
-	                chldfp = fdopen(pipefds[0],"r");
-	                if (chldfp == NULL){
-	                    logit(NSLOG_RUNTIME_WARNING,TRUE,"fdopen error\n");
-	                    _exit(EXIT_FAILURE);
-	                }
-	
-	                while(fgets(output_buffer,sizeof(output_buffer)-1,chldfp)){
-	                    temp_buffer=escape_newlines(output_buffer);
-	                    dbuf_strcat(&checkresult_dbuf,temp_buffer);
-	                    my_free(temp_buffer);
-	                }
-	
-	                fclose(chldfp);
-	                waitpid(pid,&chldstatus,0);
-	                pclose_result=chldstatus;
-	            }
-	            else{
-	                log_debug_info(DEBUGL_CHECKS,0,"running process %s via popen\n",processed_command);
-	                fp=popen(processed_command,"r");
-	                if(fp==NULL)
-	                    _exit(STATE_UNKNOWN);
-	    
-	                strcpy(output_buffer,"");
-	    
-	                while(fgets(output_buffer,sizeof(output_buffer)-1,fp)){
-	                    temp_buffer=escape_newlines(output_buffer);
-	                    dbuf_strcat(&checkresult_dbuf,temp_buffer);
-	                    my_free(temp_buffer);
-	                    }
-	    
-	                pclose_result=pclose(fp);
-	            }
 			/* reset the alarm */
 			alarm(0);
 
@@ -1045,7 +1099,7 @@ int handle_async_service_check_result(service *temp_service, check_result *queue
 
 	/* DISCARD INVALID FRESHNESS CHECK RESULTS */
 	/* If a services goes stale, Icinga will initiate a forced check in order to freshen it.  There is a race condition whereby a passive check
-	   could arrive between the 1) initiation of the forced check and 2) the time when the forced check result is processed here.  This would 
+	   could arrive between the 1) initiation of the forced check and 2) the time when the forced check result is processed here.  This would
 	   make the service fresh again, so we do a quick check to make sure the service is still stale before we accept the check result. */
 	if((queued_check_result->check_options & CHECK_OPTION_FRESHNESS_CHECK) && is_service_result_fresh(temp_service,current_time,FALSE)==TRUE){
 		log_debug_info(DEBUGL_CHECKS,0,"Discarding service freshness check result because the service is currently fresh (race condition avoided).\n");
@@ -2946,13 +3000,11 @@ int run_scheduled_host_check_3x(host *hst, int check_options, double latency){
 int run_async_host_check_3x(host *hst, int check_options, double latency, int scheduled_check, int reschedule_check, int *time_is_valid, time_t *preferred_time){
 	char *raw_command=NULL;
 	char *processed_command=NULL;
-	char output_buffer[MAX_INPUT_BUFFER]="";
 	char *temp_buffer=NULL;
 	struct timeval start_time,end_time;
 	pid_t pid=0;
 	int fork_error=FALSE;
 	int wait_result=0;
-	FILE *fp=NULL;
 	int pclose_result=0;
 	mode_t new_umask=077;
 	mode_t old_umask;
@@ -3176,22 +3228,7 @@ int run_async_host_check_3x(host *hst, int check_options, double latency, int sc
 			max_debug_file_size=0L;
 
 			/* run the plugin check command */
-			fp=popen(processed_command,"r");
-			if(fp==NULL)
-				_exit(STATE_UNKNOWN);
-
-			/* initialize buffer */
-			strcpy(output_buffer,"");
-
-			/* get all lines of plugin output - escape newlines */
-			while(fgets(output_buffer,sizeof(output_buffer)-1,fp)){
-				temp_buffer=escape_newlines(output_buffer);
-				dbuf_strcat(&checkresult_dbuf,temp_buffer);
-				my_free(temp_buffer);
-				}
-
-			/* close the process */
-			pclose_result=pclose(fp);
+			pclose_result=run_check(processed_command,&checkresult_dbuf);
 
 			/* reset the alarm */
 			alarm(0);
@@ -3223,7 +3260,7 @@ int run_async_host_check_3x(host *hst, int check_options, double latency, int sc
 				fprintf(check_result_info.output_file_fp,"early_timeout=%d\n",check_result_info.early_timeout);
 				fprintf(check_result_info.output_file_fp,"exited_ok=%d\n",check_result_info.exited_ok);
 				fprintf(check_result_info.output_file_fp,"return_code=%d\n",check_result_info.return_code);
-				fprintf(check_result_info.output_file_fp,"output=%s\n",(checkresult_dbuf.buf==NULL)?"(null)":checkresult_dbuf.buf); 
+				fprintf(check_result_info.output_file_fp,"output=%s\n",(checkresult_dbuf.buf==NULL)?"(null)":checkresult_dbuf.buf);
 
 				/* close the temp file */
 				fclose(check_result_info.output_file_fp);
@@ -3342,7 +3379,7 @@ int handle_async_host_check_result_3x(host *temp_host, check_result *queued_chec
 
 	/* DISCARD INVALID FRESHNESS CHECK RESULTS */
 	/* If a host goes stale, Icinga will initiate a forced check in order to freshen it.  There is a race condition whereby a passive check
-	   could arrive between the 1) initiation of the forced check and 2) the time when the forced check result is processed here.  This would 
+	   could arrive between the 1) initiation of the forced check and 2) the time when the forced check result is processed here.  This would
 	   make the host fresh again, so we do a quick check to make sure the host is still stale before we accept the check result. */
 	if((queued_check_result->check_options & CHECK_OPTION_FRESHNESS_CHECK) && is_host_result_fresh(temp_host,current_time,FALSE)==TRUE){
 		log_debug_info(DEBUGL_CHECKS,0,"Discarding host freshness check result because the host is currently fresh (race condition avoided).\n");
diff --git a/include/icinga.h b/include/icinga.h
index 7b9d413..b63265c 100644
--- a/include/icinga.h
+++ b/include/icinga.h
@@ -46,8 +46,7 @@ extern "C" {
    command file. EG 10/19/07
 */
 #define MAX_PLUGIN_OUTPUT_LENGTH                8192    /* max length of plugin output (including perf data) */
-#define MAXCHLDARGS    20
-
+#define MAX_CMD_ARGS 				4096	/* max number of arguments for command call on plugin */
 
 
 /******************* DEFAULT VALUES *******************/
-- 
1.7.1

